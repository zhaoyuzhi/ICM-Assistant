# -*- coding: utf-8 -*-
import os
import argparse

# read a folder, return the complete path of all files
def get_files(path):
    ret = []
    for root, dirs, files in os.walk(path):
        for filespath in files:
            ret.append(os.path.join(root, filespath))
    return ret

# read a folder, return all the sub-folders
def get_dirs(path):
    ret = []
    for root, dirs, files in os.walk(path):
        for filespath in files:
            fullpath = os.path.join(root, filespath)
            dirname = fullpath.split('\\')[-2]
            if dirname not in ret:
                ret.append(dirname)
    return ret

# multi-layer folder creation
def check_path(path):
    if not os.path.exists(path):
        os.makedirs(path)

# save a list to a txt
def text_save(content, filename, mode = 'a'):
    # try to save a list variable in txt file.
    # Use the following command if Chinese characters are written (i.e., text in the file will be encoded in utf-8)
    file = open(filename, mode, encoding = 'utf-8')
    # file = open(filename, mode)
    for i in range(len(content)):
        file.write(str(content[i]) + '\n')
    file.close()

# read a txt expect EOF
def text_readlines(filename, mode = 'r'):
    # try to read a txt file and return a list.Return [] if there was a mistake.
    try:
        # Use the following command if there is Chinese characters are read
        file = open(filename, mode, encoding = 'utf-8')
        # file = open(filename, mode)
    except IOError:
        error = []
        return error
    content = file.readlines()
    # This for loop deletes the EOF (like \n)
    for i in range(len(content)):
        content[i] = content[i][:len(content[i]) - 1]
    file.close()
    return content

# post-process list generated by LLaVA (should have \n)
def post_process_llava(llava_list, name_list, input_keywords = 'Prior information:'):
    llava_post_list = []
    temp = ''
    for j in range(len(llava_list)):
        if llava_list[j].split('/')[-1] not in name_list:
            if not llava_list[j].startswith(input_keywords):
                if len(llava_list[j]) > 0 and llava_list[j] != '':
                    temp = temp + llava_list[j] + ' '
        else:
            if temp:
                temp = temp.replace('1. ', '')
                temp = temp.replace('2. ', '')
                temp = temp.replace('</s>', '') # there is </s> at the end
                llava_post_list.append(temp.replace('  ', ' ').strip())
                temp = ''
            llava_post_list.append(llava_list[j].split('/')[-1])
    if temp:
        temp = temp.replace('1. ', '')
        temp = temp.replace('2. ', '')
        temp = temp.replace('</s>', '') # there is </s> at the end
        llava_post_list.append(temp.strip())
    return llava_post_list

if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument("--base_folder_path", type=str, default='./CoT_prompts_1/all_LLaVA_results')
    parser.add_argument("--save_folder_path", type=str, default='./CoT_prompts_1/all_LLaVA_results_revised')
    args = parser.parse_args()

    # run this after getting all results
    keywords_list = get_dirs(args.base_folder_path)
    check_path(args.save_folder_path)

    for i, keywords in enumerate(keywords_list):
        llava_list = text_readlines(os.path.join(args.base_folder_path, keywords, 'llava.txt'))
        name_list = text_readlines(os.path.join(args.base_folder_path, keywords, 'name_list.txt'))
        
        # post-process lists
        # -------------------------------------------------
        llava_post_list = post_process_llava(llava_list, name_list)
        # -------------------------------------------------
        
        # save
        save_path = os.path.join(args.save_folder_path, keywords + '.txt')
        text_save(llava_post_list, save_path)
        